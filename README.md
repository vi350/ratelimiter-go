# FloodControl
### Что нужно было сделать
Реализовать интерфейс с методом для проверки правил флуд-контроля. Если за последние N секунд вызовов метода Check будет больше K, значит, проверка на флуд-контроль не пройдена.
- Интерфейс FloodControl располагается в файле main.go.
- Флуд-контроль может быть запущен на нескольких экземплярах приложения одновременно, поэтому нужно предусмотреть общее хранилище данных. Допустимо использовать любое на ваше усмотрение.
- Хорошо, если добавите поддержку конфигурации итоговой реализации. Параметры — на ваше усмотрение.
### Ход мыслей
В первую очередь для решения этой задачи вспоминается алгоритм leaky bucket. Но по условию 2, нужно было организовать доступ из нескольких экземпляров, а значит нужно было вынести хранение данных в отдельное хранилище, из-за чего был выбран Redis, так как нам нужно быстро читать и записывать, а не заботиться о, например, констистентности. А так как даже у простой пары ключ-значение в Redis можно установить ttl, был выбран алгоритм fixed window. Он хоть и не так "плавно" работает, но реализуется единоразовым заданием ttl при создании пары.
<br>
<br>
Для того чтобы оставить возможность имплементации решения как на другой системе хранения, так и другим алгоритмом, весь код был разложен по модулям. 
### Что было сделано
- Реализован интерфейс FloodControl и перенесен в пакет floodcontrol.
- Реализован рейтлимитер в пакете floodcontrol.
- Рейтлимитер поддерживает настройку префикса.
- FloodControl может получать лимит и период из .env файла и env var'ов.
- Подключение к Redis настраивается в .env файле и env var'ах.
- Приложение контейнезировано
- Приложение обёрнуто в docker compose со всеми необходимыми внешними зависимостями.
### Использование
```bash
cp .env.example cp.env
```
```bash
docker compose up
```
Куда слать запросы: http://localhost:8000/check
